test_run = require('test_run').new()
---
...
test_run:cmd("push filter '.*/init.lua.*[0-9]+: ' to ''")
---
- true
...
netbox = require('net.box')
---
...
fiber = require('fiber')
---
...
REPLICASET_1 = { 'storage_1_a', 'storage_1_b' }
---
...
REPLICASET_2 = { 'storage_2_a', 'storage_2_b' }
---
...
test_run:create_cluster(REPLICASET_1, 'main')
---
...
test_run:create_cluster(REPLICASET_2, 'main')
---
...
test_run:wait_fullmesh(REPLICASET_1)
---
...
test_run:wait_fullmesh(REPLICASET_2)
---
...
test_run:cmd("create server router_1 with script='main/router_1.lua'")
---
- true
...
test_run:cmd("start server router_1")
---
- true
...
replicaset1_uuid = test_run:eval('storage_1_a', 'box.info.cluster.uuid')[1]
---
...
replicaset2_uuid = test_run:eval('storage_2_a', 'box.info.cluster.uuid')[1]
---
...
test_run:cmd("push filter '"..replicaset1_uuid.."' to '<replicaset_1>'")
---
- true
...
test_run:cmd("push filter '"..replicaset2_uuid.."' to '<replicaset_2>'")
---
- true
...
_ = test_run:cmd("switch router_1")
---
...
-- gh-46: Ensure a cfg is not destroyed after router.cfg().
cfg.sharding ~= nil
---
- true
...
util = require('util')
---
...
-- gh-24: log all connnect/disconnect events.
test_run:grep_log('router_1', 'connected to ')
---
- 'connected to '
...
--
-- Initial distribution
--
util.check_error(vshard.router.call, 1, 'read', 'echo', {123})
---
- null
- type: ShardingError
  bucket_id: 1
  code: 9
...
replicaset, err = vshard.router.bucket_discovery(1); return err == nil or err
---
- type: ShardingError
  bucket_id: 1
  code: 9
...
vshard.router.bootstrap()
---
...
--
-- gh-48: more precise error messages about bucket unavailability.
--
util.check_error(vshard.router.call, vshard.consts.BUCKET_COUNT + 1, 'read', 'echo', {123})
---
- 'Bucket is unreachable: bucket id is out of range'
...
util.check_error(vshard.router.call, -1, 'read', 'echo', {123})
---
- 'Bucket is unreachable: bucket id is out of range'
...
replicaset, err = vshard.router.bucket_discovery(1); return err == nil or err
---
- true
...
replicaset, err = vshard.router.bucket_discovery(2); return err == nil or err
---
- true
...
test_run:cmd('switch storage_2_a')
---
- true
...
box.space._bucket:replace({1, vshard.consts.BUCKET.SENDING})
---
- [1, 'sending']
...
test_run:cmd('switch storage_1_a')
---
- true
...
box.space._bucket:replace({1, vshard.consts.BUCKET.RECEIVING})
---
- [1, 'receiving']
...
test_run:cmd('switch router_1')
---
- true
...
-- Ok to read sending bucket.
vshard.router.call(1, 'read', 'echo', {123})
---
- 123
...
-- Not ok to write sending bucket.
util.check_error(vshard.router.call, 1, 'write', 'echo', {123})
---
- null
- {'type': 'ShardingError', 'code': 7, 'bucket_id': 1}
...
test_run:cmd('switch storage_2_a')
---
- true
...
box.space._bucket:replace({1, vshard.consts.BUCKET.ACTIVE})
---
- [1, 'active']
...
test_run:cmd('switch storage_1_a')
---
- true
...
box.space._bucket:delete({1})
---
- [1, 'receiving']
...
test_run:cmd('switch router_1')
---
- true
...
-- Check unavailability of master of a replicaset.
test_run:cmd('stop server storage_2_a')
---
- true
...
util.check_error(vshard.router.call, 1, 'read', 'echo', {123})
---
- null
- type: ShardingError
  unreachable_uuid: <replicaset_2>
  code: 8
  bucket_id: 1
...
test_run:cmd('start server storage_2_a')
---
- true
...
--
-- gh-26: API to get netbox by bucket identifier.
--
vshard.router.route(vshard.consts.BUCKET_COUNT + 100)
---
- null
- type: ShardingError
  bucket_id: 3100
  code: 9
...
util.check_error(vshard.router.route, 'asdfg')
---
- 'Usage: router.route(bucket_id)'
...
util.check_error(vshard.router.route)
---
- 'Usage: router.route(bucket_id)'
...
conn = vshard.router.route(1)
---
...
conn.state
---
- active
...
-- Test missing master.
rs_uuid = '<replicaset_2>'
---
...
rs = vshard.router.internal.replicasets[rs_uuid]
---
...
master = rs.master
---
...
rs.master = nil
---
...
vshard.router.route(1)
---
- null
- type: ShardingError
  replicaset_uuid: <replicaset_2>
  code: 6
...
rs.master = master
---
...
-- Test reconnect on bucker_route().
rs:disconnect()
---
- true
...
conn = vshard.router.route(1)
---
...
conn:wait_connected()
---
- true
...
conn.state
---
- active
...
--
-- Function call
--
bucket_id = 1
---
...
test_run:cmd("setopt delimiter ';'")
---
- true
...
customer = {
    customer_id = 1,
    name = "Customer 1",
    bucket_id = bucket_id,
    accounts = {
        {
            account_id = 10,
            name = "Credit Card",
            balance = 100,
        },
        {
            account_id = 11,
            name = "Debit Card",
            balance = 50,
        },
    }
}
test_run:cmd("setopt delimiter ''");
---
...
vshard.router.call(bucket_id, 'write', 'customer_add', {customer})
---
- true
...
vshard.router.call(bucket_id, 'read', 'customer_lookup', {1})
---
- {'accounts': [{'account_id': 10, 'balance': 0, 'name': 'Credit Card'}, {'account_id': 11,
      'balance': 0, 'name': 'Debit Card'}], 'customer_id': 1, 'name': 'Customer 1'}
...
vshard.router.call(bucket_id + 1, 'read', 'customer_lookup', {1}) -- nothing
---
- null
...
--
-- Test errors from router call.
--
new_bid = vshard.consts.BUCKET_COUNT + 1
---
...
space_data = {{1000, {{1}, {2}}}}
---
...
-- Insert in a not existing space - it must return box.error.
vshard.router.call(bucket_id, 'write', 'vshard.storage.bucket_recv', {new_bid, 'from_uuid', space_data})
---
- null
- {'type': 'ClientError', 'message': 'Space ''1000'' does not exist', 'code': 36,
  'trace': [{'file': '[C]', 'line': 4294967295}]}
...
--
-- Monitoring
--
vshard.router.info().replicasets[1].master.state
---
- active
...
vshard.router.info().replicasets[2].master.state
---
- active
...
--
-- Configuration: inconsistency master=true on storage and routers
--
-- This test case flips masters in replicasets without changing
-- configuration on router and tests NON_MASTER response
--
-- Test the WRITE request
vshard.router.call(1, 'write', 'echo', { 'hello world' })
---
- hello world
...
-- Shuffle masters
util.shuffle_masters(cfg)
---
...
-- Reconfigure storages
test_run:cmd("switch storage_1_a")
---
- true
...
cfg.sharding = test_run:eval('router_1', 'return cfg.sharding')[1]
---
...
vshard.storage.cfg(cfg, names['storage_1_a'])
---
...
test_run:cmd("switch storage_1_b")
---
- true
...
cfg.sharding = test_run:eval('router_1', 'return cfg.sharding')[1]
---
...
vshard.storage.cfg(cfg, names['storage_1_b'])
---
...
test_run:cmd("switch storage_2_a")
---
- true
...
cfg.sharding = test_run:eval('router_1', 'return cfg.sharding')[1]
---
...
vshard.storage.cfg(cfg, names['storage_2_a'])
---
...
test_run:cmd("switch storage_2_b")
---
- true
...
cfg.sharding = test_run:eval('router_1', 'return cfg.sharding')[1]
---
...
vshard.storage.cfg(cfg, names['storage_2_b'])
---
...
-- Test that the WRITE request doesn't work
test_run:cmd("switch router_1")
---
- true
...
util.check_error(vshard.router.call, 1, 'write', 'echo', { 'hello world' })
---
- null
- {'type': 'ShardingError', 'code': 2, 'bucket_id': 1}
...
-- Reconfigure router and test that the WRITE request does work
vshard.router.cfg(cfg)
---
...
vshard.router.call(1, 'write', 'echo', { 'hello world' })
---
- hello world
...
_ = test_run:cmd("switch default")
---
...
test_run:drop_cluster(REPLICASET_2)
---
...
-- gh-24: log all connnect/disconnect events.
while test_run:grep_log('router_1', 'disconnected from ') == nil do fiber.sleep(0.1) end
---
...
test_run:cmd("stop server router_1")
---
- true
...
test_run:cmd("cleanup server router_1")
---
- true
...
test_run:drop_cluster(REPLICASET_1)
---
...
test_run:cmd('clear filter')
---
- true
...
